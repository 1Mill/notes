# The Effective Engineer

<https://www.effectiveengineer.com/>

## Key Takeaways

* TODO

## Notes

### Foreword

* Working as a PO for a larger company is about delivering value and managing politics to a larger extend then a startup which is more weighted towards delivering value.
* Low leverage (relationships, touch points) are what many bureaucratic cultures teach versus high leverage (results, capability) is what drives meaingful success.
* When presented with a problem, don't think first about "How do we do this", ask "Why do we need to do it at all?"
* "... effective engineering was not corelated with hours of effort ..."

### Introduction

* "The harder we worked, the more value we could produce, and the more likely it was that our startup would succeeed. Or so I thought."
* Work smarter, not harder: find the bets which require the least amount of effort believed to yield the most customer value.
* "Not all efforts, however well-intentioned, translate into impact."

* "Effective engineers ... get things done efficiently"
  * Recognize they don't have unlimited resource
  * Recgonize opportunities worth doing and those that are not
  * Work smarter, not harder
  * Focus on realistic value and impact for today
  * Avoid overengineering / optimizing for the future which doens't exist yet (e.g. infastructure which an scale to 100 million customers when you currently have 10 customers total)

### Part 1: Adopting the right mindset

### Focus on high leverage activities

* Pair new hires with existing hires for 2-3 months to facilitate effective onboarding and learning of how the organization runs.
* Reoccuring Tech Talks + Codelabs (workshops + homework) to teach and validate comprehsion of core systems to grow collective understanding.

### Use Leverage as your yardstick for effectiveness

* `Leverage = Impact Producted / Time Invested`
* Leverage is a way to measure Return on Investment (ROI)
* Time is the most valauble resource: it cann't be saved up or stored in reserve for the future like money, it is always being spent.
* Pareto Principle: 80% of the impact comes from 20% of the work
* Pairing programming, even just for 1 hour, is a high leverage activity
  * Share tooling knowledge to speed up other person (e.g. use script X to do Y)
  * Share business knowledge to spee up other person (e.g. avoid pitfall X)
  * Share technical knowlege to speed up other person (e.g. write code in X style)
* Pair programming is a minor investement to drive alignment and really onboard people quickly.
* Startup success depend more on the team then the capabilities of any one single person, so effective onboarding is a high leverage activity.

### Increase your leverage in three ways

How to increase leverage:

1. By reduciing the time it takes to complete a certain activity (Woody Zuill: make the work easier)
2. By increasing the output of a particular activity (Woody Zuill: make the work effortless)
3. By shifting to higher-leverage activities (Woody Zuill: Make the work unnessesary)

Questions to increase leverage:

1. How can I complete this acivity in a shorter amount of time?
2. How can I increase the value prduced by this activity?
3. Is there something else that I could psend my time on that would poduce more value?

* Going through the motions does not mean value is being produced.

### Direct Energy towards leverage oints, not just easy wins

* High leverage activities are not always quick easy wins, sometimes they require consistent effort over long periods of time to drive high leverage.

### Key takeaways

* Use leverage to measure your engineering effectivness.
* Systemtically increase the leverage of your time.
* Focus your effort on leverage points.

### Optimize for learning

* "Optimizing for learning is a high-leverage activity for the effective engineer ..."
* "... a growth mindset is a prerequisite for improving our abilities."

### Adopt a growth mindset

* Connecting with others opens more opportunities than going alone.
* "... how we view our own effectiveness impacts how much effort we invest in improving it."
* "The students who were taught about the nature of intelligence and how it could be increased through experience and hard work saw their math grades improve over the year."
  * How can we incorporate such messaging into our team language?
* "own your story"
* Growth mindset: believe capabilities can improve; fixed indset: believe capabilities are fixed.
* "... [take] control of the parts of [your] story that [are] within [your] sphere of influence."
* "... optimize for exeprience where you learn rather than for experience where you effortlessly succeed."

### Invest in your rate of learning

* Compound interst is a modern marvel
* Learning is compounding
  1. The more you learn today, the easier it is to learn new stuff more quickly tomorrow
  2. Invest in learning early - just like retirement
  3. Small deltas in personal learning lead to huge difference in the long run
* Reference: Delivering Happiness (Zappos CEO)
* Improving by 1% every day is a high leverage investment

### Seek work environments conductive to learning

* When choosing a new job, look for
  1. Fast growth creates more opportunities to grow personally
  2. Training / effectove onboarding "... indicates the team prioritizes professional growth."
      * "What new things have team members learned recently?"
  3. Openness to continous improvement by seeking feedback
  4. Faster pace from idea to delivery gives you more opportunities to learn
  5. People around you are more important for learning than the work you end up doing
  6. Autonomy enables you to learn more quickly because you can choose the areas you want to learn more about rather than being assigned something.

### Dedicate time on the job to develop new skills

* It is easy to fall into the Capability Trap because of all the work teams need to get done, so they are always trying to catch up: never improving or learning.
* Carve out 20% time to learn (Woody Zuill think it should be 50%) in 1-2 daily hour chunks
* Use team to learn more about the work
  * Improve at tooling
  * Improve understanding of domain
  * Improve at neighboring disciplines
* To get better at a skill, you need do to rote learning of the basics - you can't just jump into complex topics and expect to be efficient if you don't know the basics.
  * What the basics are change from discipline to discipline.
  * Reading about is not the same as skills in a skill, technique, etc.
* "... interleaved practice of different skills i more effective then repeated, massed practice of a single skill at prepairing people to tackle unfamiliar problems."
  * [Interleaved practice](https://psychology.ucsd.edu/undergraduate-program/undergraduate-resources/academic-writing-resources/effective-studying/other-learning-techniques.html#:~:text=Interleaved%20practice%20%E2%80%93%20when%20you%20are,B%20on%20the%20next%2C%20you): "when you are learning two or more related concepts or skills, instead of focusing exclusively on one concept or skill at a time, it can be helpful to alternate between them"
* "Create learning opportunities out of your 20% time ..."

### Always be learning

* "... continual learning is injextricably linked with increased hapiness."
* Invest in these areas
  * Learning new programing languages or frameworks
  * Invest in skills thare are in high demand
  * Read books
  * Join a discussion group
  * Attend talks, conference, meetups
  * Biuld and mtain a strong network of relationships
  * Follow bloggers who teach
  * Write to teach
  * Tinker on the side
  * Pursue what you love.
* Reading book is a high leverage investment because you learn from others who already have the experience so you don't have to start from the ground up and rediscover the wheel.
* Networking creates more opportunities for lucky encounters

### Key takeaways

* Own your story: focus on chages within your sphere of influence / control; don't spend too much energy on area's you can't control
* Don't shortchange your learning rate: the more you learn, the easier it is to learn more in the future; learning is compouding
* Find work environments that can sustain your growth
* Capitilize on opportunities to improve technical skills at work: learn from the best within the org.
* Locate learning opportunities outside of work: strive to become 1% better every day

### Prioritize Regularly

* Focus on how customers flow into and out of the product to maximize ROI.
* "Even small 0.5% wins in key areas can compound like interest and add a million users down the line."
  * Reminders me of Duo Lingo's culture about learning fast by experimenting fast
* Working on the wrong items not only returns 0 compounding interest - it eats up opportunity cost setting you back
  * Small, incremental bets over large changes.
* Reprioritization is a high level activity

### Tackel to-dos in a single, easily accessible list

* Checklists eliminate large chunks of avoidable errors - so have a check list of everything that needs to get done
* Human brain is optimized for processing information, not storing information
* Garbage data in, get garbage data out for estimates, predicted ROI, etc.
* Better to do and learn over trying to predict the future and doing nothing (or very little)
  * How much waste in estimates?
* Continously ask "Is there something else I could be doing that's higher leverage?"

### Focus on what directly produces value

* Time and effort do not equal profitable customer value.
* Prioritize the ideas which feel like they will produce the most value for the least amount of effort
  * Building this feeling is a high leverage activity

### Focuson the important and non-urgent

* "We let life's daily interruptions, rather than our priorities, dictate our schedules."
* Urgency is not the same thing as important - other's peoples fires don't have to be your fires.

* Urgen + important
  * Crises
  * Deadlines
* Non-urgent + important
  * Planning
  * Prevention
  * Building relationships
  * Personal development

* Dedicated time to continous learning may be slow at first, but will increase long term effectiveness which out weights initial slowness / investement
* In your to-do list of taks for a day, label things 1 - 4 for the different quadrants to know what is important vs unimportant and priority

### Product your maker's schedule

* Achieving flow (as in the state of mind) requires deep focus without distractions
* 30 minutes is barly enough time for a maker to get started on a task
* Create large, dedicated blocks for making / doing

### Limit the amount of work in progress

* Multi-tasking is one thing being worked on and everything else being blocked.
* Serialize different projects to reduce context switching
* Focus on done over started
* Teams not working as teams because they fracture into solo contributors lose slowly lose the same working context making PRs and conversations less efficient.
  * Competing priorities divide the team and the lowest bandwith common element becomes a bottleneck.

### Fight procrastination with if-then plans

* If-then planning ahead of time to fight of procrastination so big and important things can be meaningfully tackled, even if just in smaller chunks.

* In a to-do list, give each task a number representing how many 25 minute chunks are predicted to complete that task
  * Done
    * [1] Review tasks for today
    * [1] Check with team on results from last weeks UI expeirment
  * Doing
    * [2] Investigate and fix bug
  * Today
    * [6] Prototype expeirment for new UI
  * This week
    * [6] Write first draft of article

* Spend one chunk Daily to review and set the to-do list for that day.
* Spend one chunk on Friday to reflect on the week, and outline opportunities for next week.

### Key takeaways

* Write down and review to-dos.
* Work on what directly leads to value.
* Work on the important and non-urgent.
* Reduce context switches.
* Make if-then plans to combat procrastination.
* Make prioritization a habit.

### Part 2: Execute, execute, execute

### Invest in iteration speed

* Continuous deployment (CD) reduces the amount of work done and when coupled with CI and automated tests reduces deployment anxiety.
* Automation and observability lets teams move faster than manual repetition and anxeity.
* Manual or batched deploys contribute to cycle time.
* Configuration / feature flags allow teams to deploy unfinished code so that code can be continously integrated
  * Avoid "merge hell"
* Effective engineers invest heavily in iteration speed

### Most fast to learn fast

* The faster you can deploy, release, and iterate increase the opportunity to do and learn more.
* CD lets team focus on small batches and more than likely right where the issue is if something goes wrong.

### Invest in time-saving tools

* Slowing down / create slack in the system to incrementally invest in process improvements such as tooling.
* Time saved creates opportunities to
  * Do and learn more
  * Enable new opportunities not prevously feasible
* Tools scale across people and teams: having a significant impact on productivity if / when adopted.
* The cost of switching tools can be high, discouraging adoption: try to make adoption cheap.
* Avoid the capability trap where you never invest time to improve your process and/or tooling

### Shorten your debugging and validation loops

* Take a step back to reflect and uncover better ways of working

### Master your programming environment

* Pair programming is a great way to learn about shortcuts to improve productivity.
* "Mastery is a process, not an event"
* Learn to use hotkeys

### Don't ignore your non-engineering bottlenecks

* Cycle time is composed of many elements, many of them are not code related. When looking to improve, look for the bottlenecks across the entire cycle from idea to done.
* Seek feedback early and often, even through unofficial channels. Though, this is probably a sign the process is broken to begin with.
* Projects fail from under communication, (rarely) over communication
* Be aware of your sphere of influence to know where to invest your time in improvements

### Key takeaways

* THe faster you can iterate, the more you can learn
* Moving to slowly to avoid mistakes errodes opportunity cost
* Invest in tooling
* Optimize your debugging workflow.
* Master the fundamentals of your craft
* Take a holistic view of your iteration loop

### Measure what you want to improve

* Measure customer happiness / delight
* Long clicks in Google Search results (behavior which indicated a successful search had happened because the user no longer interacted with the search results pages) was a success / deligt indicator
* Long click metrics over time provided deeper business insights into different types of searches (e.g. news vs food vs actors; is "houston baker" a person or a company search?)
* Metrics influence which work gets prioritizied.
* Be skeptical of data integrity

### Use metrics to drive progress

* "If you can't measure it, you can't improve it"
* Metrics help guard against regression (e.g. is the product or process getting worse over time?)
* Performance ratcheting: establish a current baseline / status quo, and never let the metric go above that baseline. Ideally, over time through other improvements this baseline slowly decreases.

### Pick the right metric to incentivize the behavior you want

* Make sure the customer metrics align with customer outcomes.
  * Short clicks at Google mean the search results were bad, long clicks mean the search results were good
* Metrics influence decisions and behaviors - [Hawthorne effect](https://en.wikipedia.org/wiki/Hawthorne_effect)
* What you don't measure is just as important
* Instead of writing 3 hours per day, focus on writing 1,000 words per day creates a change in mindset and behavior.
* When deciding a metric to use, choose metrics which fulfill all three traits:
  1. When optimized for, maximizes impact
  2. Are actionable
  3. Are responsive and robust
* Reference: Good to Great
  * Align all employees around a single metric called the "economic denominator"
  * Profit per X; what is the X factor that everybody should focus on and improve the most collectively?
* Vanity metrics don't measure actually customer interactions with the core of the product; actionable metrics should be linkable to feature releases.
* Responsive metrics tell you if a change was good or bad.
* Balance responsiveness and robustness - tracking something minute-by-minute is very volitile and unreliable versus perhaps hour-by-hour of month-by-month depending on what you are measuring.

### Instrument everything to understand whats going on

* Instrumentation / product analytics let teams know when things are going wrong and where to look to implement fixes rather than flying blind.
* Observability helps detect and traige problems which builds confidence in continous deployment practicies.

### Internalized useful numbers

* Have ballpark benchmarks for how your system operates so you know if features, pages, code, etc. are being slow so they need to be optimized or much faster so you can learn how to better optimize other instances.

### Be skeptical about data integrity

* Be wary of P-hacking personally or from others for political purposes
* Once you compute a metric ask, "Does this make sense?"

### Key takeaways

* Measure your progress
* Carefully choose your top-level metric.
* Instrument your system
* Know your numbers
* Prioritize data integrity

### Validate your ideas early and often

* Seek feedback early and often by releasing early and often, even just to alpha / beta users.
* Customer feedback is the most valuable feedback.
* Optimize workflows / team processes for getting customer feedback
  * Customer interviews
  * A/B testing

### Find low-effort ways to validate your work

* The more often you validate you are heading the correct direction, the more decision points you create to address errors, bugs, or know if you are heading in the wrong direction
* Incorrect assumptions compoud into worse and worse outcomes over longer periods of time
* Building a prototype is cheaper and provides more valuable insight than building the whole thing and being wrong.
* Building a fake implemenetation into the product is a great strategy to guage customer interest in some new feature

### Continuously validate product changes with A/B Testing

* Using intuitition to know where to improve, prototypes to understand the improvements and collect early estimates for impact, and then use A/B testing to validate (or invalidate) speculated impact.
* A/B testing is time intensive, which means expensive - know where and where not to test.

### Beware the one-person team

* Tiny PRs are less risky, easier to review, and easier to fix if going the wrong direction than large PRs.
* Incentive and team processes often encourage one-person teams owning a single project, even if on paper they belong to a larger team.
* Other "teammates" don't have context or detaile knowledge to support one-person team projects once that one-person is gone or know how to provide meaingful feedback.
* Anti-pattern: Hero Programming.

* Strategies to increase the chance for feedback:
  * Be open and receptive to feedback - don't be defensive.
  * Commit code early and often - iteratnive progress vs large changes to make feedback more meaningful and easly to get from others
  * Requst code revies from thorough critics - better to get hard feedback early from peers than customers later
  * Ask to bounce ideas off your teammates - seek feedback early and often
  * Design the interface or API of the new system first - the developer experience is just another form of the customer experience wher you are the customer of your own code so make it simple to use.
  * Send out a design document before devoting your enegy to your code - validate you are solving the right customer problem with the right solutions and to get feedback about forseeable pitfals.
  * If possible, structure ongoing porjects so that there is osome shared context with your teammates - pair programming, team swarming; focus on the flow of done and successful work, not on the activity of doing the work.
  * Solicit buy-in from controversial features before investing too much time - get good at office politics to get good at getting buy-in and getting valuable feedback.

* Software development is a team sport, optimize for feedback.

### Build feedback loops for your decisions

* Every decision needs a feedback loop, otherwise you are just guessing and hoping it is working for the best which is often not the case.
* Run experiments on team processes / with how teams work to uncover better ways of working.
  1. Form a hypothesis
  2. Design an experiment
  3. Think about good and bad outcomes
  4. Run the experiment
  5. Review findings

### Key takeaways

* Approach a problem iteratively to reduce wasted effort - make learning cheap.
* Reduce the risk of large implementations by using small validations.
* Use A/B testing to continuously validate your product hypotheses.
* Adopt a willingness to validate your decisions - feedback loops are critical to learning and learning is critical to change.

### Improve your project estimation skills

* Automated tests via TDD help with deployment axiety and not breaking existing features.

### Use accurate estimates to drive project planning

* Estimates: best guesse around timing created by engineers; Targets: desired buisness goals created by business leaders.

* Strategies
  * Decomopse the porject into granular tasks of less than 2 days of work
  * Estimate based on how long tasks will take, not on how long you or someone else wants them to take
  * Think of estimates as robability distributions, not best-case scenarios.
  * Let the person doing the actual task make the estimate.
  * Beware of anchoring bias
  * Use multiple approaches to estimate the same task
  * Beware the mythical man-month - adding more people to a project won't speak it up; each person works at a different pace so one perons estimate may be radically differnt than anothers
  * Validate estimates against istorical data
  * Use timeboxing to constrain tasks that can grow in scope or may be too open ended (e.g. which database should we use?)
  * Allow others to challenge estimates

* Visulize projections versus actuals to improve estimations

### Budget for the unknown

* A project taking 5 days does not always equate to next week: it is 5 working days of work, not 5 calandar days from now. Meetings, jury duty, etc. start and stop these working days.
* Create a conversion rate: 1 engineering day is 2 calendar days to account for interuptions

### Define specific project goals and measureable milestones

* "First, a well-defined goal provides an important filter for separating the must-haves form the nice-to-haves in the task list."
* Having a well defined goal makes it easy to juxtapose ideas to stay focused
* Concrete milestones have (1) have a clear goal and (2) have a clear projected calandar date

### Reduce Risk Early

* Start with the riskiest stuff first, not the easiest stuff, to better inform earily projections / estimates.
* Integrating with sub-systems grows quickly in complexity so edge cases are a common cause of increasing scope and calendar days.

### Approach rewrite projects with extreme caution

* Rewrite projects are some of the riskiest projects.
* Small, incremental and opinionated milestones are better than doing everything all at once.

### Don't sprint in the middle of a marathon

* Hourly productivity dcreases with each additional hour worked
* 60+ hours per work for more than 2 months is less productive than just normal 40 hour weeks
* More hours leads to more burnout.
* Overtime is often followed up by undertime where people become more lax at work to catch up on life.
* More communication overhead means less time to work
* Working fast enocurages technical debt over quality.

### Key takeaways

* Incorporate estimates into the poroject plan - don't let the target dictact the estimate
* Allow buffer room for the unknown in the schedule
* Define measurable milestones
* Do the riskiest tasks first
* Know the limits of overtime

### Balance quality and pragmatism

* Rigid coding practicies discourage quick and dirty prototyping - something that has its pros and cons.
* High quality code is stable and easy to change, but diminishing returns with being too rigid around coding practicies.


### Establish a sustainable code review process

* Code reviews are good for
  * Catching buts or design shortcomings early
  * Increasing accountability for code changes
  * Positive modeling of how to write good code
  * Sharing working knowledge of the codebase
  * Increasing long-term agility
* Dropbox didn't adopt code reviews for their first 4 years
* There are many ways to do code reviewing (e.g. pair programming, post-merge)
* Evolve your process to and use automation as much as reasonabily possible for syntax things.

### Manage complexity through abstraction

* Engineergs, and businesses, care about application logic first and foremost.
* The right abstractions increase engineering productivity
  * Reduces the complexityf of the original problem into easy-to-understand primitives.
  * Reduces and centralizes maintenance and future improvements
  * Solves the hard problem once and makes it reusable.
* Time saved must be outweighed by time invested - over engineering is wasteful.
* Building the product is more important for startups than having the perfect tool, especially when building the perfect tool from scratch.
* Early abstractions may be overfitting for the handful of use cases today - bad abstractions add more friction to the development process.
* Good abstractions should be
  * Easy to learn
  * Easy ot use even without documentation
  * Hard to misuse
  * Sufficiently powerful to satisfy requirements
  * Easy to extend
  * Appropriate to the audiance
* Simple abstractions handle one concept; they don't try to juggle multiple concepts.

### Automated testing

* Automated testing scales more simply and cost effectively than manual testing
* Automated tests reduce deployment anxiety (e.g. did my change break something I am not aware of somewhere else?)
* Just a few integration tests verifying core workflows continue to work is a high leverage activity
* Look for strategic tests to start with to reduce cycle time - don't start with the goal of 100% code coverage.

### Repay technical debt

* The feeling / need to ship sooner often creates a lot of technical debt.
* "Technical debt refers to all the deferred wor that's necessary to improve the health and quality of the codebase and that would slow us down if left unaddressed."
* With our first implementation we don't have a complete understanding of the problem we are solving, so surviver bias immediately creates technical debt.
* Take on technical debt iteratively, avoid a whole rewrite which is often doomed to grow.

### Key takeaways

* Establish a culture of reviewing code
* Invest in good software abstractions to simplify difficult problems
* Scale code quality with automated tests
* Manage your technical debt

### Minimize operational burden

* "Shaving time off reoccuring costs frees you to focus on what matters most"
* Everything from features to infastructure must be maintainted which costs time - make this stuff simple to manage and do.

### Embrace Operational Simplicity

* "Effective engineers focus on simplicity"
* Always ask: "Is this the simlilist thing" (i.e. iteration, process, etc.) for what we are trying to do?

* Commplex architectures have high upkeep costs
  * Engineering expertise gets splintered across multiple systems
  * Increased complexity introduces more potential single points of failure.
  * New wengineers face steeper learning curve when learning and understanding the new systems
  * Efort towards improviing abstractions, libraries, and tools get diluted across the different systems

* Scale horizontally by adding more of the same component instead of vertically by adding more complexity.

### Build systems to fail fast

* No nulls - throw errors quickly and often.
* Surfacing errors fast means they can be addressed faster than failing slowly or silently.
* Don't fail fast for customers, but be sure to notify engineerings about the error quickly - try to fail gracefully for customers.

### Relentlessly automative mechnical tasks

* Time is our most valuable resource.

* Engineers don't automate for the following resources:
  * They don't feel like they have the time right now
  * They suffer from the tragedy of the commons (i.e. bad team structures or company cultures which encourage social loafing over action)
  * They alck familiarity with automation tools.
  * They underestimate the future frequency of the task
  * They don't feel the time savings over a long time horizon (e.g. 10 seconds per task is huge over a 1 year period in productivity)

* Do automate mechanics (e.g. deploying); don't automate decision making (i.e. should I deploy?)
* Machenics are often easy to automated; decisions are often not easy to automate and can become time sinks because they quickly grow in scope because of the amount of complex intreactions happening with decision making - especially if it isn't part of your customer value

### Make batch processes idempotent

* Idempotence - ability to run multiple times but only apply the expected side-effects once.
* Reentrantce - ability to run multiple times

* Run scripts early and often to catch failures caused by other changes in the system, even if it is just a dry run.

### Hone your ability to respond and recover quickly

* Netflix has Chaos Monkey which randomly skills severs during working hours so engineers can fix issues during the work week rather than the weekend.
* Higher leverage activity is to focus on faster recovery rather than preventing bugs
* "Script for success" - write out a play book for quick recovery

### Key takeaways

* Do the simple things first
* Fail fast to he pinpoint the source of the error
* Automate mechnics over decision-making
* Aim for idempotence and reentrancy
* Plan and practice failure modes

### Invest in your team's growth

* Engineering leaders are measured more on their impact on others than their individual contributions.
* Help other succeed - rising tides lift all boats.

### Make hirng everyone's responsibilities

* Make the interview process fun but rigorous
* Leet code is not real world or practical working expeirence - use better practicies to screen canidates.

* High-leverage interview stratagies
  * Take time with your team to identify which qualities in a potential team-mate you care about the most (e.g. mastery, debugging, communication, culture fit, etc.) and make sure all are covered in the interview process
  * Meet regularly to refine interview process
  * Design interview problems to have multiple layers of difficulty from so you can add and remove layers to make problems easier or harder to guague capability
  * Control ther interview pace to maintain high signal-to-noise ratios - don't get bogged down in meaningless noise.
  * Scan for red flags using rapid fire short-answer questions to cover a large surface area of topics
  * Shadow and/or pair during interview to improve interrater reliability
  * Use unconventional interview approaches if they help you identify the signals your team cares about

### Design a good onboarding process

* Investing in people early to be more effectively is a one-time upfront cost that pays for itself in the long run.
* Building onboarding resources can be amoritized.

* Goals for an onboarding program
  * Ramp up new engineers as quickly as possible
  * Impart the team's culture and values.
  * Expose new engineers to the breadth of fundamentals needed to succeed
  * Socially integrate new engineers onto the team.

* Core mechanics for onboarding programs
  * Codelabs - Document outlining key tools, technologies, and abstractions
  * Onboarding talks - Make sure key tools, technologies, and abstractions are socialized
  * Mentorship - Pair new hires with senior members to facilitating learning and overall onboarding
  * Starter tasks - Get new hires familiar with the code and how the organization works starting simple and slowly adding complexity

* Reflect on your own onboarding experiences to know where to improve.

### Share ownership of the code

* A lack of collective code ownership means more bottle necks and more single points of failure.
* Invest in team learning so the team can maintain the code - not individuals.

* Strategies to encourage collective code ownership:
  * Avoid one-person teams
  * Code reviews
  * Rotate tasks and responsibilities to encourage leveling up / learning
  * Keep code readable and code quality high
  * Present tech talks on software decisions and architecture
  * Document your software in high-level documents or code comments
  * Document complex workflows or non-obvious workarounds
  * Invest time in teaching and mentoring other team members

### Build collective wisdom through post-mortems

* Hold post-mortem retrospectives after each project to reflect and learn where you can continue to improve before starting the next project.
* Share / socialize learnings from retrospectives so other teams can learn from your improvements instead of being doomed to repeat the same lessons.
* NASA Flight Rules is a tomb of all steps and their reasons for encounting previously encountered problems during space flight - a manifestation of the collective wisdom of the crowd.
  * Also includes previous project retrospectives - what worked and what didn't; previous experiments ran; etc.
* Reference: 5 Whys to discover the root cause of a symptom
* Optimize your process to maximize collective learning.

### Build a great engineering culture

* Empowered engineers get things done, which makes them happier and more productive and translates into retention.

* Great engineering cultures cultivate:
  * Optimize for iteration speed
  * Push relentlessly towards automation
  * Build the right software abstractions
  * Focus on high code quality by using code reviews
  * Maintain a respectful work environment
  * Build shared ownership of code
  * Invest in automated testing
  * Allot experimentation time, either through 20%time or hackathons
  * Foster a culture of learning and continous improvement
  * Hire the best

* High leverage investments are often the ones which cultivate great engineering cultures which creates an environment for engineers to do great works.
* Cultivate a great engineering culture through high-leverage investments which makes great works inevitible.

### Key takeaways

* Help the people around you be successful
* Make hiring a priority
* Invest in onboarding and mentoring
* Build shared ownership of code
* Debreif and document collective wisdom
* Create a great engineering culture.
